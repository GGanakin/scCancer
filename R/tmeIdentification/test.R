#' Process scibet.core
#' @name pro.core
#' @usage pro.core(scibet.core)
#' @param scibet.core A SciBet core
#' @return A processed SciBet core
#' @export
pro.core <- function(scibet.core){
  cell.type <- unname(unlist(scibet.core[,1]))
  scibet.core <- as.data.frame(t(scibet.core[,-1]))
  colnames(scibet.core) <- cell.type
  return(as.matrix(scibet.core))
}

Dropout_Sampling <- function(lambda){
  nondropout <- as.matrix(1 - lambda)
  z <- c()
  for(i in 1:nrow(nondropout)){
    pos.prob <- nondropout[i,1]
    newz <- sample(0:1, ncol(nondropout), replace = TRUE, 
                   prob = c(1 - pos.prob, pos.prob))
    z <- rbind(z, newz)
  }
  rownames(z) <- rownames(nondropout)
  colnames(z) <- colnames(nondropout)
  return(as.matrix(z))
}

#' @name MLEstimate
#' @param test Rows should be cells and columns should be genes.
#' @param prob trained scibet model  Rows should be genes
#' and columns should be cell types.The genes must be matched with test_r
#' @param ret_tab   return list or matrix
#' @return  'cellType'  or matrix
MLEstimate <- function(test, prob, lambda, 
                       weighted.markers=NULL,
                       dropout.modeling=FALSE,
                       ret_tab=FALSE){
  #\sigma yi*logpi (log(p1p2) = logp1 + logp2, log(p^y) = ylogp)
  if (length(weighted.markers) > 0){
    markers <- names(weighted.markers)
    weight <- unname(weighted.markers)
    prob[which(rownames(prob) %in% markers),] <- 2 * prob[which(rownames(prob) %in% markers),] 
  }
  if (dropout.modeling){
    # z~Bernoulli(1-lambda)
    # z <- Dropout_Sampling(lambda)
    # likelihoods <- as.matrix(test) %*% (as.matrix(prob) * z)
    # Expectation of log-likelihoods.
    likelihoods <- as.matrix(test) %*% (as.matrix(prob) * as.matrix(1 - lambda))
  }
  else{
    likelihoods <- as.matrix(test) %*% as.matrix(prob)
  }
  cellType <- c()
  for(i in 1:nrow(likelihoods)){
    index <- which.max(likelihoods[i,])
    cellType <- c(cellType,colnames(likelihoods)[index])
  }
  out <- likelihoods/rowSums(likelihoods)
  if(ret_tab){
    return(out)
  }
  return(cellType)
}

#' Predict cell type and show accuracy
#' @name Test
#' @usage Test(prob, test, result="list")
#' @param prob A matrix generated by Train(cellType-genes prob-matrix)
#' @param test testset with rows being cells, and columns being genes.
#' @return cellType prediction result
#' @export
Test <- function(prob, lambda, test_set,
                 weighted.markers=NULL,
                 dropout.modeling=FALSE,
                 average.expr=NULL){
  if(!is.null(average.expr)){
    test <- average.expr
    genes <- rownames(prob)
    common.genes <- intersect(genes, colnames(test))
    test.normalized <- log1p(as.matrix(test[,common.genes])) / log(2)
    predict <- MLEstimate(test.normalized, prob[common.genes, ], 
                          lambda[common.genes, ], 
                          weighted.markers,
                          dropout.modeling, FALSE)
    names(predict) <- seq(from = 0, to = length(predict) - 1)
    return(predict)
  }
  else{
    test <- test_set[,-ncol(test_set)]
    genes <- rownames(prob)
    common.genes <- intersect(genes, colnames(test))
    test.normalized <- log1p(as.matrix(test[,common.genes])) / log(2)
    predict <- MLEstimate(test.normalized, prob[common.genes, ], 
                          lambda[common.genes, ], 
                          weighted.markers,
                          dropout.modeling, FALSE)
    correct <- 0
    for (i in 1:length(predict)){
      if (test_set$label[i] == predict[i]){
        correct <- correct + 1
      }
    }
    print(correct / length(predict))
    return(predict)
  }
}

#' Predict cell type and show accuracy
#' @name CrossTest
#' @usage CrossTest(prob, test_set)
#' @param prob A matrix generated by Train(cellType-genes prob-matrix)
#' @param test_set testset with rows being cells, and columns being genes.
#' @return cellType prediction result
#' @export
CrossTest <- function(prob, test_set){
  # test <- test_set[,-ncol(test_set)]
  genes <- rownames(prob)
  common.genes <- intersect(genes, colnames(test_set))
  testa <- log1p(as.matrix(test_set[,common.genes])) / log(2)
  predict <- MLEstimate(testa, prob[common.genes, ], FALSE)
  return(predict)
}

MarkerScore <- function(test_set, marker_file_path,
                        cutoff=.30, database = org.Hs.eg.db,
                        metacell = FALSE){
  # check markers on test set, set unknown labels
  set.seed(unclass(Sys.time()))
  object <- scibet_visualization(test_set, metacell = metacell)[["object"]]
  average.expr <- NULL
  clustering <- NULL
  if(metacell){
    average.expr <- data.frame(t(AverageExpression(object)[[1]]))
    clustering <- as.character(object@meta.data[["RNA_snn_res.100"]])
  }
  object <- as.CellDataSet(object)
  object <- estimateSizeFactors(object)
  # adjust cutoff parameter
  marker_check <- check_markers(object, marker_file_path, 
                                db=database, 
                                cds_gene_id_type = "SYMBOL", 
                                marker_file_gene_id_type = "SYMBOL")
  weighted.markers <- 1 + log(1 + marker_check$marker_score)
  names(weighted.markers) <- marker_check$marker_gene
  result <- select_fine_samples(cds = object,
                                marker_file = marker_file_path,
                                db=database,
                                cds_gene_id_type = "SYMBOL",
                                cutoff = cutoff,
                                num_unknown = 50,
                                marker_file_gene_id_type = "SYMBOL",
                                return_initial_assign = TRUE)
  unknown.index <- which(result$Assignment == "None")
  return(list(average = average.expr,
              clustering = clustering,
              unknown = unknown.index,
              markers = weighted.markers))
}

AssignUnknown <- function(predict, unknown.index){
  # calculate accuracy after "unknown"s are excluded
  correct <- 0
  predict.unknown <- predict
  for (i in 1:length(predict)){
    if (i %in% unknown.index){
      predict.unknown[i] <- "unknown"
      next
    }
    if (test_set$label[i] == predict[i]){
      correct <- correct + 1
    }
  }
  print(correct / (length(predict.unknown) - length(unknown.index)))
  return(predict.unknown)
}